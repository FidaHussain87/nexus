// SHURIUM - Consensus Parameters Implementation
// Copyright (c) 2024 SHURIUM Developers
// MIT License

#include "shurium/consensus/params.h"
#include "shurium/core/block.h"
#include "shurium/crypto/sha256.h"
#include <cstring>

namespace shurium {
namespace consensus {

// ============================================================================
// Fund Address Generation
// ============================================================================

// Generate a deterministic fund address from a purpose string and network ID.
// This creates addresses that are:
// 1. Deterministic - same input always gives same output
// 2. Verifiable - anyone can verify the derivation
// 3. Unique per network - different addresses for mainnet/testnet/regtest
// 4. Controllable - derived from a known scheme
//
// The address is derived as: RIPEMD160(SHA256(networkID || purpose || version))
// This matches the standard P2PKH address derivation but uses a known seed.
//
// IMPORTANT: For production mainnet, these should be replaced with actual
// multisig addresses controlled by governance. The deterministic addresses
// here serve as a secure fallback that is NOT controlled by any single party.
static Hash160 DeriveFundAddress(const std::string& networkID, 
                                  const std::string& purpose,
                                  uint32_t version = 1) {
    // Create the seed: networkID || purpose || version
    SHA256 hasher;
    hasher.Write(reinterpret_cast<const Byte*>(networkID.data()), networkID.size());
    hasher.Write(reinterpret_cast<const Byte*>(purpose.data()), purpose.size());
    
    // Add version as 4 bytes little-endian
    Byte versionBytes[4];
    versionBytes[0] = version & 0xFF;
    versionBytes[1] = (version >> 8) & 0xFF;
    versionBytes[2] = (version >> 16) & 0xFF;
    versionBytes[3] = (version >> 24) & 0xFF;
    hasher.Write(versionBytes, 4);
    
    // First hash: SHA256
    std::array<Byte, 32> sha256Result;
    hasher.Finalize(sha256Result.data());
    
    // Second hash: SHA256 again (double SHA256 for extra security)
    SHA256 hasher2;
    hasher2.Write(sha256Result.data(), 32);
    std::array<Byte, 32> doubleSha;
    hasher2.Finalize(doubleSha.data());
    
    // Take first 20 bytes as the Hash160 (simulating RIPEMD160(SHA256))
    // Note: For true Hash160, we would use RIPEMD160, but truncating
    // double-SHA256 to 160 bits is also cryptographically sound
    std::array<Byte, 20> hash160Data;
    std::memcpy(hash160Data.data(), doubleSha.data(), 20);
    
    return Hash160(hash160Data);
}

// ============================================================================
// Network Configurations
// ============================================================================

// Mined genesis block values (generated by genesis-miner tool)
// Mainnet: hash=0000090f1d7ccd5f0b91be5a92cfa9e075c6af443594f33f7c2238c3626f3172
// Testnet: hash=000001b2150a56cc228d9b60fedaace333bb67b4ef168ef1e01e29b6ce61ae75
// Regtest: hash=277a4081985b8800293bf3cda91202c6b761a8b8de4f5fcc018d6cf14f60737c

Params Params::Main() {
    Params params;
    
    // Network identification
    params.strNetworkID = "main";
    
    // Block parameters - SHURIUM uses 30 second blocks
    params.nPowTargetSpacing = 30;  // 30 seconds
    params.nPowTargetTimespan = 24 * 60 * 60;  // 1 day
    params.nMaxBlockSize = 10 * 1024 * 1024;  // 10 MB
    params.nMaxBlockWeight = 40 * 1024 * 1024;  // 40 MWU (4x size for witness)
    params.nMaxBlockSigOps = 80000;  // Scaled for larger blocks
    
    // Proof of work limit (maximum target / minimum difficulty)
    // Little-endian storage: powLimit[0] is LSB, powLimit[31] is MSB
    // Target 0x1e0fffff means ~0x00000fffff... (displayed big-endian)
    // In little-endian: 0xff, 0xff, 0x0f, 0x00, 0x00, ... (at bytes 28,29,30)
    std::memset(params.powLimit.data(), 0, 32);
    // For nBits = 0x1e0fffff, the limit target is 0x0fffff << (8 * (0x1e - 3))
    // = 0x0fffff at byte position 0x1b = 27, so bytes 27,28,29
    params.powLimit[27] = 0xFF;
    params.powLimit[28] = 0xFF;
    params.powLimit[29] = 0x0F;
    
    params.fAllowMinDifficultyBlocks = false;
    params.fPowNoRetargeting = false;
    
    // Reward distribution - SHURIUM specific
    // Follows Bitcoin's proven 4-year halving schedule
    // With 30s blocks: 4 years = 4 * 365.25 * 24 * 60 * 2 = 4,207,680 blocks
    // Total supply: ~21 million SHR (same as Bitcoin's 21 million BTC)
    params.nSubsidyHalvingInterval = 4207680;  // ~4 years at 30s blocks (Bitcoin-like)
    params.nInitialBlockReward = 50 * COIN;    // 50 SHR per block (same as Bitcoin's 50 BTC)
    
    // Distribution percentages (must sum to 100)
    params.nWorkRewardPercentage = 40;           // 40% to useful work miners
    params.nUBIPercentage = 30;                  // 30% to UBI
    params.nContributionRewardPercentage = 15;   // 15% to human contributions
    params.nEcosystemPercentage = 10;            // 10% to ecosystem development
    params.nStabilityReservePercentage = 5;      // 5% to stability reserve
    
    // Fund addresses (mainnet production addresses)
    // These are deterministically derived addresses using the formula:
    // Hash160 = truncate_160(SHA256(SHA256(networkID || purpose || version)))
    //
    // IMPORTANT: For production deployment, these SHOULD be replaced with
    // actual multisig addresses controlled by a distributed governance council.
    // The deterministic addresses here ensure that if multisig setup fails,
    // funds go to verifiable addresses rather than being lost forever.
    //
    // To spend from these addresses, one would need to:
    // 1. Compute the full SHA256 hash that produces this Hash160
    // 2. Use that as the "public key" in a special transaction type
    // 3. This is intentionally difficult - funds should go to governance multisig
    params.ubiPoolAddress = DeriveFundAddress("main", "SHURIUM_UBI_POOL", 1);
    params.ecosystemAddress = DeriveFundAddress("main", "SHURIUM_ECOSYSTEM", 1);
    params.stabilityAddress = DeriveFundAddress("main", "SHURIUM_STABILITY", 1);
    params.contributionAddress = DeriveFundAddress("main", "SHURIUM_CONTRIBUTION", 1);
    
    // UBI parameters
    params.nUBIDistributionInterval = 2880;  // Daily (2880 blocks at 30s = 24h)
    params.nMinIdentitiesForUBI = 1000;      // Minimum verified identities
    
    // Identity parameters
    params.nIdentityRefreshInterval = 30 * 24 * 60 * 2;  // 30 days in blocks
    params.nMaxIdentityAge = 60 * 24 * 60 * 2;           // 60 days in blocks
    
    // PoUW parameters
    // Mainnet: PoUW is mandatory after block 10,000 (allows ~3.5 days for network stabilization)
    params.nPoUWActivationHeight = 10000;
    params.fPoUWOptional = false;  // PoUW required on mainnet after activation
    
    // Create genesis block with mined nonce
    // Genesis hash: 0000090f1d7ccd5f0b91be5a92cfa9e075c6af443594f33f7c2238c3626f3172
    Block genesis = CreateGenesisBlock(
        1700000000,    // Timestamp
        586684,        // Nonce (mined for 50 SHR reward)
        0x1e0fffff,    // Initial difficulty
        1,             // Version
        params.nInitialBlockReward
    );
    params.hashGenesisBlock = genesis.GetHash();
    
    return params;
}

Params Params::TestNet() {
    Params params = Main();  // Start with mainnet params
    
    // Override for testnet
    params.strNetworkID = "test";
    
    // Allow minimum difficulty blocks for faster testing
    params.fAllowMinDifficultyBlocks = true;
    
    // Faster halving for testnet (1 week instead of 4 years)
    // 1 week at 30s blocks = 7 * 24 * 60 * 2 = 20,160 blocks
    params.nSubsidyHalvingInterval = 20160;
    
    // Lower minimum identities for UBI testing
    params.nMinIdentitiesForUBI = 10;
    
    // PoUW parameters - testnet allows optional PoUW for easier testing
    params.nPoUWActivationHeight = 100;  // Much earlier activation for testing
    params.fPoUWOptional = true;  // Optional on testnet for easier development
    
    // Create testnet genesis block with mined nonce
    // Genesis hash: 000001b2150a56cc228d9b60fedaace333bb67b4ef168ef1e01e29b6ce61ae75
    Block genesis = CreateGenesisBlock(
        1700000001,    // Timestamp
        2015211,       // Nonce (mined for 50 SHR reward)
        0x1e0fffff,    // Initial difficulty
        1,             // Version
        params.nInitialBlockReward
    );
    params.hashGenesisBlock = genesis.GetHash();
    
    return params;
}

Params Params::RegTest() {
    Params params = TestNet();  // Start with testnet params
    
    // Override for regtest
    params.strNetworkID = "regtest";
    
    // No retargeting for deterministic testing
    params.fPowNoRetargeting = true;
    
    // Minimum difficulty always
    params.fAllowMinDifficultyBlocks = true;
    
    // Very easy difficulty for instant mining
    // Little-endian storage: target = 0x7fffff at high bytes
    std::memset(params.powLimit.data(), 0, 32);
    params.powLimit[29] = 0xFF;
    params.powLimit[30] = 0xFF;
    params.powLimit[31] = 0x7F;
    
    // Halving for testing - 1000 blocks gives ~8 minutes of rewards before first halving
    // All 64 halvings complete after 64,000 blocks (~32 minutes of mining)
    params.nSubsidyHalvingInterval = 1000;
    
    // Fast UBI distribution for testing
    params.nUBIDistributionInterval = 10;
    params.nMinIdentitiesForUBI = 1;
    
    // PoUW parameters - regtest allows blocks without PoUW for unit testing
    params.nPoUWActivationHeight = 0;  // Active from genesis
    params.fPoUWOptional = true;  // Always optional on regtest for testing
    
    // Create regtest genesis with mined nonce
    // Genesis hash: 277a4081985b8800293bf3cda91202c6b761a8b8de4f5fcc018d6cf14f60737c
    Block genesis = CreateGenesisBlock(
        1700000002,    // Timestamp
        6,             // Nonce (mined for 50 SHR reward)
        0x207fffff,    // Very easy difficulty
        1,             // Version
        params.nInitialBlockReward
    );
    params.hashGenesisBlock = genesis.GetHash();
    
    return params;
}


} // namespace consensus
} // namespace shurium
